#!/usr/bin/env python3

# MIT License
#
# Copyright (c) 2018-2023 Jonny Tyers
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

from __future__ import annotations
from attrs import define
import click
import os
import subprocess
import shlex
import shutil
from typing import Generator
from typing import Optional

def expand(path):
    if path is None:
        return None

    if type(path) is list:
        return [os.path.expanduser(os.path.expandvars(x)) for x in path]

    elif type(path) is str:
        return " ".join(expand(path.split(" ")))

    else:
        return os.path.expanduser(os.path.expandvars(path))


xdg_runtime_dir = os.environ.get(
    "XDG_RUNTIME_DIR", expand(f"/run/user/{os.getuid()}")
)
xdg_config_home = os.environ.get("XDG_CONFIG_HOME", expand("$HOME/.config"))
xdg_cache_home = os.environ.get("XDG_CACHE_HOME", expand("$HOME/.cache"))
xdg_data_home = os.environ.get("XDG_DATA_HOME", expand("$HOME/.local/share"))

@define
class NoSuchProfileError(Exception):
    profile_name: str

@define
class ProfileAlreadyExistsError(Exception):
    profile_name: str

@define
class QutebrowserProfile:
    parent: QutebrowserProfiles
    profile_name: str
    session: str = 'default'

    @property
    def basedir(self):
        return os.path.join(f"{self.parent.xdg_runtime_dir}/qutebrowser/{self.profile_name}")

    def mkbasedir(self):
        # https://github.com/ayekat/localdir/blob/35fa033fb1274807c907a4a83431d3a8222283f6/lib/dotfiles/wrappers/qutebrowser
        # https://wiki.archlinux.org/index.php/Qutebrowser#dwb-like_session_handling
        #
        # Wrapper around qutebrowser that makes sessions (-r, --restore SESSION) behave
        # like they used to in dwb.
        #
        # We do so by filtering out the -r/--restore option passed to qutebrowser and
        # using the argument to set up the following directory structure and symbolic
        # links:
        #
        # $XDG_RUNTIME_DIR/qutebrowser/$session/cache → $XDG_CACHE_HOME/qutebrowser/$session
        # $XDG_RUNTIME_DIR/qutebrowser/$session/data → $XDG_STATE_HOME/qutebrowser/$session
        # $XDG_RUNTIME_DIR/qutebrowser/$session/data/userscripts → $XDG_DATA_HOME/qutebrowser/userscripts
        # $XDG_RUNTIME_DIR/qutebrowser/$session/config → $XDG_CONFIG_HOME/qutebrowser
        # $XDG_RUNTIME_DIR/qutebrowser/$session/runtime (no symlink, regular directory)
        #
        # We then specify $XDG_RUNTIME_DIR/qutebrowser/$session as a --basedir, and the
        # files will end up in their intended locations (notice how the config directory
        # is the same for all sessions, as there is no point in keeping it separate).
        #
        # DISCLAIMER: The author of this script manages all his configuration files
        # manually, so this wrapper script has not been tested for the use case where
        # qutebrowser itself writes to these files (and more importantly, if multiple
        # such "sessions" simultaneously write to the same configuration file).
        #
        # YOU HAVE BEEN WARNED.
        #
        # Written by ayekat in an burst of nostalgy, on a mildly cold wednesday night in
        # February 2017.
        #
        # Enhanced a little by jonny on a dreary cold Friday morning in December 2018.
        #

        for d in [
            self.basedir,
            f"{self.parent.xdg_config_home}/qutebrowser",
            f"{self.parent.xdg_cache_home}/qutebrowser/{self.profile_name}",
            f"{self.parent.xdg_data_home}/qutebrowser/{self.profile_name}",
            f"{self.basedir}/runtime",
        ]:
            os.makedirs(d, exist_ok=True)

        for src, dst in [
            (f"{self.parent.xdg_config_home}/qutebrowser", f"{self.basedir}/config"),
            (f"{self.parent.xdg_cache_home}/qutebrowser/{self.profile_name}", f"{self.basedir}/cache"),
            (f"{self.parent.xdg_data_home}/qutebrowser/{self.profile_name}", f"{self.basedir}/data"),
        ]:
            if os.path.exists(dst):
                os.unlink(dst)
            os.symlink(src, dst, target_is_directory=False)

@define
class QutebrowserProfiles:
    profiles_root: str

    xdg_runtime_dir: str
    xdg_cache_home: str
    xdg_data_home: str
    xdg_config_home: str

    _profiles: Optional[list[QutebrowserProfile]] = None

    def _populate_profiles(self) -> list[QutebrowserProfile]:
        """Populates _profiles if needed, then returns them."""
        if self._profiles is None:
            self._profiles = []
            for item in os.listdir(self.profiles_root):
                if self._exists(item):
                    self._profiles.append(QutebrowserProfile(parent=self, profile_name=item))

        return self._profiles

    def profiles(self) -> list[QutebrowserProfile]:
        return list(self._populate_profiles())  # new list to prevent external changes

    def get_profile(self, profile_name: str) -> QutebrowserProfile:
        for profile in self._populate_profiles():
            if profile.profile_name == profile_name:
                return profile

        raise NoSuchProfileError(profile_name)

    def _exists(self, profile_name):
        """Checks if a profile with the given name exists under profiles_root. Looks at the filesystem
        and not at the _profiles cache."""
        item_path = os.path.join(self.profiles_root, profile_name)

        # our profilesRoot may contain dirs that are not qutebrowser profiles, so we look for
        # the 'state' file to determine whether something is a profile, and then pipe thru dirname
        # find "$profilesRoot" -mindepth 2 -maxdepth 2 -name state -type f -printf "%P\n" | xargs dirname
        return os.path.isdir(item_path) and os.path.exists(os.path.join(item_path, 'state'))

    def new(self, profile_name) -> QutebrowserProfile:
        """Creates a new QutebrowserProfile as part of this QutebrowserProfiles instance, including
        its profile dirs."""
        if self._exists(profile_name):
            raise ProfileAlreadyExistsError(profile_name)

        result = QutebrowserProfile(parent=self, profile_name=profile_name)
        self._populate_profiles().append(result)
        result.mkbasedir()

        return result


    def run_qb(self, qutebrowser: str, profile: QutebrowserProfile, args: list[Optional[str]] = [], show_stdio: bool = False):
        if not isinstance(profile, QutebrowserProfile):
            raise ValueError(f'profile must be a QutebrowserProfile, not {type(profile)}')


        # (--basedir) basedir_specified=1 ;;
        # (-r|-[!-]*r|--restore) test $# -gt 0 && session="$1" && shift && continue ;;

        # Set up session base directory, unless --basedir has been specified by the
        # user:
        profile.mkbasedir()

        # Translate options: remove occurrences of -r/--restore from the list of
        # command line arguments and save the session name for later
        for idx, arg in enumerate(args):
            if arg is None:
                continue
            if arg in ['--restore', '-r' ]:
                args[idx] = None
                args[idx+1] = None
            if arg in ['--override-restore', '-R' ]:
                args[idx] = None

        args = [ qutebrowser, '--basedir', profile.basedir ] + list(filter(lambda x: x is not None, args))

        stdin = None
        stderr = None
        stdout = None

        if not show_stdio:
            stdin = subprocess.DEVNULL
            stderr = subprocess.DEVNULL
            stdout = subprocess.DEVNULL

        p = subprocess.Popen(args, stdin=stdin, stdout=stdout, stderr=stderr)
        print(f'started process {p.pid}')


@click.command(context_settings=dict(
    ignore_unknown_options=True,
))
@click.option(
    "--profiles-root",
    default=expand(f"{xdg_data_home}/qutebrowser"),  # "/run/user/$uid/qutebrowser"
    help="The directory to store profiles in",
)
@click.option(
    "--choose/--no-choose",
    default=False,
    help="Prompt the user to choose a profile, then launch it",
)
@click.option(
    "--load",
    default=None,
    help="Load the given profile (fails if profile does not exist, see --new)",
)
@click.option(
    "--new/--no-new",
    default=False,
    help="Allow --load to create a new profile if it does not exist",
)
@click.option(
    "--dmenu",
    required=False,
    help="Override the location of dmenu/rofi when using --choose",
)
@click.option(
    "--only-existing/--no-only-existing",
    default=False,
    help="Do not allow the user to specify a new (non-existent) profile during --choose",
)
@click.option(
    "--list-profiles/--no-list-profiles", "--list/--no-list", '-l/ ',
    default=False,
    help="List existing profiles",
)
@click.option(
    "--show-stdio/--no-show-stio",
    default=False,
    help="Show stdout/stderr from qutebrowser when it is launched",
)
@click.option(
    "--qutebrowser",
    default=shutil.which("qutebrowser"),
    help="Location of qutebrowser launcher",
)
# eat up remaining args to pass to qutebrowser
@click.argument('qb_args', nargs=-1, type=click.UNPROCESSED)
def main(
    profiles_root: str,
    choose: bool,
    load: Optional[str],
    new: bool,
    dmenu: Optional[str],
    only_existing: bool,
    list_profiles: bool,
    qutebrowser: str,
    qb_args: tuple[str],
    show_stdio: bool,
):
    # Set default values as defined in XDG base directory spec
    # https://specifications.freedesktop.org/basedir-spec/latest/

    qp = QutebrowserProfiles(
        profiles_root=profiles_root,
        xdg_runtime_dir = xdg_runtime_dir,
        xdg_config_home = xdg_config_home,
        xdg_cache_home = xdg_cache_home,
        xdg_data_home = xdg_data_home,
    )

    if not list_profiles or load or choose:
        choose = True

    if list_profiles:
        if choose or load:
            raise click.BadParameter('cannot use --choose, --list or --load together')

        profiles = qp.profiles()
        for profile in profiles:
            print(profile)

    if choose:
        if list_profiles or load:
            raise click.BadParameter('cannot use --choose, --list or --load together')

        profiles = qp.profiles()

        if not dmenu:
            rofi = shutil.which("rofi")
            if rofi:
                dmenu = f"{rofi} -dmenu"

            dmenu = shutil.which("dmenu")

        if not dmenu:
            # use terminal selection
            for idx, profile in enumerate(profiles):
                print(f'{idx+1}. {profile.profile_name}')

            print('')
            print('Choose a number or name: ')
            ans = input()

            try:
                idx = int(ans)
                profile = profiles[idx-1]

            except ValueError: # ans wasn't a number
                profile = qp.get_profile(ans)

        else:

            dmenuArgs = shlex.split(dmenu) + ["-p", "qutebrowser"]

            if only_existing:
                dmenuArgs.append("-no-custom")

            p = subprocess.Popen(dmenuArgs,
                                     stdin=subprocess.PIPE,
                                     stderr=subprocess.PIPE,
                                     stdout=subprocess.PIPE)

            choice_lines = '\n'.join(map(lambda px: px.profile_name, profiles))
            choice, errors = p.communicate(choice_lines.encode('utf-8'))

            if p.returncode not in [0, 1] or (p.returncode == 1 and len(errors) != 0):
                raise ValueError(
                    "{} returned {} and error:\n{}"
                    .format(dmenuArgs, p.returncode, errors.decode('utf-8'))
                )

            profile_name = choice.decode('utf-8').rstrip()
            profile = qp.get_profile(profile_name)

        qp.run_qb(qutebrowser=qutebrowser, profile=profile, args=list(qb_args), show_stdio=show_stdio,)

    if load:
        if list_profiles or choose:
            raise click.BadParameter('cannot use --choose, --list or --load together')

        try:
            profile = qp.get_profile(load)
            if not profile:
                raise click.BadParameter(f'profile {load} does not exist')

        except NoSuchProfileError:
            if new:
                profile = qp.new(load)
            else:
                raise

        qp.run_qb(qutebrowser=qutebrowser, profile=profile, args=list(qb_args), show_stdio=show_stdio)


if __name__ == '__main__':
    main()
